// Copyright (c) 2022 Tom Hancocks
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include <unordered_map>
#include "codegen/lua/type_exporter.hpp"
#include "codegen/lua/ast.hpp"

// MARK: - Construction

kdl::codegen::lua::type_exporter::type_exporter(kdl::build_target::type_container &container)
    : m_container(container)
{
}

// MARK: - Code Generator

auto kdl::codegen::lua::type_exporter::generate_lua() const -> std::string
{
    ast::generator gen;

    // Setup Kestrel API
    auto resource_reader = gen.declare_class("ResourceReader", true);
    auto load_helper = gen.symbol("kdl_resourceLoader");
    auto load_helper_function = gen.declare_function(true, load_helper);
    auto read_signed_byte = gen.declare_function(true, gen.symbol("readSignedByte"), resource_reader);
    auto read_signed_short = gen.declare_function(true, gen.symbol("readSignedShort"), resource_reader);
    auto read_signed_long = gen.declare_function(true, gen.symbol("readSignedLong"), resource_reader);
    auto read_signed_quad = gen.declare_function(true, gen.symbol("readSignedQuad"), resource_reader);
    auto read_byte = gen.declare_function(true, gen.symbol("readByte"), resource_reader);
    auto read_short = gen.declare_function(true, gen.symbol("readShort"), resource_reader);
    auto read_long = gen.declare_function(true, gen.symbol("readLong"), resource_reader);
    auto read_quad = gen.declare_function(true, gen.symbol("readQuad"), resource_reader);
    auto read_pstr = gen.declare_function(true, gen.symbol("readPStr"), resource_reader);
    auto read_cstr = gen.declare_function(true, gen.symbol("readCStr"), resource_reader);
    auto read_color = gen.declare_function(true, gen.symbol("readColor"), resource_reader);
    auto read_reference = gen.declare_function(true, gen.symbol("readResourceReference"), resource_reader);
    auto read_typed_reference = gen.declare_function(true, gen.symbol("readTypedResourceReference"), resource_reader);
    auto read_macintosh_rect = gen.declare_function(true, gen.symbol("readMacintoshRect"), resource_reader);
    auto read_rect = gen.declare_function(true, gen.symbol("readRect"), resource_reader);
    auto read_point = gen.declare_function(true, gen.symbol("readPoint"), resource_reader);
    auto read_size = gen.declare_function(true, gen.symbol("readSize"), resource_reader);

    // Start building the Lua for this type.

    auto resource_reference = gen.symbol("resourceReference");

    gen.add_comment("This code was auto generated by KDL.");
    gen.new_line();
    auto klass = gen.declare_class(m_container.name());

    gen.new_line();

    auto type_code = gen.symbol("resourceTypeCode");
    auto type_code_function = gen.declare_static_function(false, type_code, klass);
    gen.begin_block();
    gen.return_statement(gen.string(m_container.code()));
    gen.end_block();

    gen.new_line();

    gen.add_comment(" Model Construction");
    auto load = gen.symbol("load");
    gen.declare_static_function(false, load, klass, { resource_reference });
    gen.begin_block();

    gen.condition(gen.apply_not(resource_reference));
    gen.begin_block();
    gen.return_statement(gen.nil());
    gen.end_block();

    gen.new_line();

    auto resource = gen.symbol("resource");
    auto data = gen.symbol("data");

    gen.local_assign(resource, gen.construct(klass));
    gen.local_assign(data, gen.call(load_helper_function, { resource, resource_reference, gen.call(type_code_function) }));

    gen.new_line();
    gen.condition(gen.apply_not(data));
    gen.begin_block();
    gen.return_statement(gen.nil());
    gen.end_block();

    std::unordered_map<std::string, std::pair<ast::ast_node *, ast::ast_node *>> m_fields;
    for (auto& field : m_container.all_fields()) {
        auto lower = field.lower_repeat_bound();
        auto upper = field.upper_repeat_bound();

        for (auto n = lower; n <= upper; ++n) {
            auto value_count = field.expected_values();
            for (auto i = 0; i < value_count; ++i) {
                auto value = field.value_at(i);
                auto name = value.extended_name({ std::pair("FieldNumber", lexeme(std::to_string(n), lexeme::integer))});
                auto bin_field = m_container.internal_template().binary_field_named(name);
                auto read_expr = gen.nil();

                ast::ast_node *member_name = gen.private_symbol(gen.camel_case(name.text()));
                if (field.is_repeatable()) {
                    member_name = gen.subscript(gen.private_symbol(gen.camel_case(field.name().text())), gen.number(n));
                }

                if (value.explicit_type().has_value()) {
                    auto type = value.explicit_type().value();
                    if (type.is_reference() && type.name().has_value()) {
                        auto named_type_code_klass = gen.declare_class(type.name().value().text(), true);
                        auto named_type_code_function = gen.declare_static_function(true, type_code, named_type_code_klass);
                        read_expr = gen.call(data, read_typed_reference, { gen.call(named_type_code_function) });
                    }
                    else if (type.is_reference()) {
                        read_expr = gen.call(data, read_reference);
                    }
                    else if (type.name().value().is("Color")) {
                        read_expr = gen.call(data, read_color);
                    }
                    else if (type.name().value().is("File")) {
                        if (bin_field.type == kdl::build_target::binary_type::PSTR) {
                            read_expr = gen.call(data, read_pstr);
                        }
                        else if (bin_field.type == kdl::build_target::binary_type::CSTR) {
                            read_expr = gen.call(data, read_cstr);
                        }
                    }
                    else if (type.name().value().is("Bitmask") || type.name().value().is("Range")) {
                        switch (bin_field.type) {
                            case kdl::build_target::binary_type::DBYT:
                                read_expr = gen.call(data, read_signed_byte);
                                break;
                            case kdl::build_target::binary_type::DWRD:
                                read_expr = gen.call(data, read_signed_short);
                                break;
                            case kdl::build_target::binary_type::DLNG:
                                read_expr = gen.call(data, read_signed_long);
                                break;
                            case kdl::build_target::binary_type::DQAD:
                                read_expr = gen.call(data, read_signed_quad);
                                break;
                            case kdl::build_target::binary_type::HBYT:
                                read_expr = gen.call(data, read_byte);
                                break;
                            case kdl::build_target::binary_type::HWRD:
                                read_expr = gen.call(data, read_short);
                                break;
                            case kdl::build_target::binary_type::HLNG:
                                read_expr = gen.call(data, read_long);
                                break;
                            case kdl::build_target::binary_type::HQAD:
                                read_expr = gen.call(data, read_quad);
                                break;
                            default:
                                break;
                        }
                    }
                }
                else {
                    switch (bin_field.type) {
                        case kdl::build_target::binary_type::PSTR:
                            read_expr = gen.call(data, read_pstr);
                            break;
                        case kdl::build_target::binary_type::DBYT:
                            read_expr = gen.call(data, read_signed_byte);
                            break;
                        case kdl::build_target::binary_type::DWRD:
                            read_expr = gen.call(data, read_signed_short);
                            break;
                        case kdl::build_target::binary_type::DLNG:
                            read_expr = gen.call(data, read_signed_long);
                            break;
                        case kdl::build_target::binary_type::DQAD:
                            read_expr = gen.call(data, read_signed_quad);
                            break;
                        case kdl::build_target::binary_type::HBYT:
                            read_expr = gen.call(data, read_byte);
                            break;
                        case kdl::build_target::binary_type::HWRD:
                            read_expr = gen.call(data, read_short);
                            break;
                        case kdl::build_target::binary_type::HLNG:
                            read_expr = gen.call(data, read_long);
                            break;
                        case kdl::build_target::binary_type::HQAD:
                            read_expr = gen.call(data, read_quad);
                            break;
                        case kdl::build_target::binary_type::RECT:
                            read_expr = gen.call(data, read_macintosh_rect);
                            break;
                    }
                }

                m_fields.emplace(std::pair(name.text(), std::pair(member_name, read_expr)));
            }
        }
    }

    gen.new_line();
    auto field_count = m_container.internal_template().binary_field_count();
    for (auto i = 0; i < field_count; ++i) {
        auto field = m_container.internal_template().binary_field_at(i);
        auto info = m_fields.at(field.label.text());

        auto member_name = gen.private_symbol(gen.camel_case(field.label.text()));
        auto read_expr = info.second;

        gen.assign(gen.member(member_name, resource), read_expr);
    }

    for (auto& field : m_container.all_fields()) {
        if (field.expected_values() <= 1 && !field.is_repeatable()) {
            continue;
        }
        gen.new_line();

        auto object = reinterpret_cast<ast::userdata_literal *>(gen.userdata_literal());
        gen.assign(gen.member(gen.private_symbol(gen.camel_case(field.name().text())), resource), object);
        gen.push(object->block());

        if (field.expected_values() == 1 && field.is_repeatable()) {
            auto value = field.value_at(0);
            for (auto n = field.lower_repeat_bound(); n <= field.upper_repeat_bound(); ++n) {
                auto name = value.extended_name({ std::pair("FieldNumber", lexeme(std::to_string(n), lexeme::integer))});
                auto bin_field = m_container.internal_template().binary_field_named(name);
                gen.assign(gen.symbol("[" + std::to_string(n) + "]"), gen.comma(gen.member(gen.private_symbol(bin_field.label.text()), resource)));
            }
        }
        else if (field.is_repeatable()) {
            for (auto n = field.lower_repeat_bound(); n <= field.upper_repeat_bound(); ++n) {
                auto sub_object = reinterpret_cast<ast::userdata_literal *>(gen.userdata_literal());
                gen.assign(gen.symbol("[" + std::to_string(n) + "]"), gen.comma(sub_object));
                gen.push(sub_object->block());

                for (auto i = 0; i < field.expected_values(); ++i) {
                    auto value = field.value_at(i);
                    auto name = value.extended_name({std::pair("FieldNumber", lexeme(std::to_string(n), lexeme::integer))});
                    auto bin_field = m_container.internal_template().binary_field_named(name);

                    gen.assign(gen.symbol(gen.camel_case(value.base_name().text())), gen.comma(gen.member(gen.private_symbol(gen.camel_case(bin_field.label.text())), resource)));
                }

                gen.pop();
            }
        }
        else {
            for (auto i = 0; i < field.expected_values(); ++i) {
                auto value = field.value_at(i);
                auto bin_field = m_container.internal_template().binary_field_named(value.base_name());
                gen.assign(gen.symbol(gen.camel_case(value.base_name().text())), gen.comma(gen.member(gen.private_symbol(gen.camel_case(bin_field.label.text())), resource)));
            }
        }

        gen.pop();

    }

    gen.new_line();
    gen.return_statement(resource);
    gen.end_block();

    gen.new_line();
    gen.add_comment("Constants");
    gen.new_line();

    auto constants_object = reinterpret_cast<ast::userdata_literal *>(gen.userdata_literal());
    gen.assign(gen.member(gen.symbol("Constants"), gen.symbol(klass->identifier())), constants_object);
    gen.push(constants_object->block());

    for (auto& field : m_container.all_fields()) {
        auto value_count = field.expected_values();
        for (auto n = 0; n < value_count; ++n) {
            auto value = field.value_at(n);
            if (value.symbols().empty()) {
                continue;
            }

            auto value_object = reinterpret_cast<ast::userdata_literal *>(gen.userdata_literal());
            gen.assign(gen.symbol(value.base_name().text()), gen.comma(value_object));
            gen.push(value_object->block());

            for (const auto& it : value.symbols()) {
                auto const_name = std::get<0>(it);
                auto const_value = std::get<1>(it);

                ast::ast_node *node = gen.nil();

                if (const_value.is(lexeme::string)) {
                    node = gen.string(const_value.text());
                }
                else if (const_value.is(lexeme::integer)) {
                    node = gen.number(const_value.value<int64_t>());
                }

                gen.assign(gen.symbol(const_name.text()), gen.comma(node));
            }

            gen.pop();
        }
    }

    gen.pop();

    gen.new_line();
    gen.add_comment("Properties");
    gen.new_line();

    for (auto& field : m_container.all_fields()) {
        auto property = gen.declare_property(klass, gen.symbol(gen.camel_case(field.name().text())));
        gen.synthesize_getter(property);
        if (field.wants_lua_setter()) {
            gen.synthesize_setter(property);
        }
        gen.new_line();
    }

    return gen.generate_lua();
}